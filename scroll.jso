autowatch = 1;


var Softstep = {};

// This is in fact a "general" scroller that works for any sort of
// device where you can scroll a portion of the
// config is a dictionary that can have the following properties:
//   delta:    how to scroll - +1 is forward, -1 backward
//   execute:  a callback function that computes the scrolling string and sends
//             it to Max (probably sending it to an outlet).
//   freeze:   freeze the display on stop, or back to offset 0 (default false).
//   message:  the message to scroll (default '').
//   period:   the delay between scroll increments, in ms (default 500).

Softstep.Scroller = function(config) {
  this.config = config || {};

  this.Start = function() {
    post('start\n');
    this.Stop();

    this.offset = 0;
    this._Execute();
    this.task = this._NewTask();
  };

  this.Stop = function() {
    post('stop\n');
    this.task && this.task.cancel();
    this.task = null;
    if (!this.config.freeze) {
      this.offset = 0;
      this._Execute();
    }
  };

  this.SetMessage = function(m) {
    this.config.message = m;
    this.offset = 0;
    this._Execute();
  };

  this.SetPeriod = function(p) {
    p = parseInt(p);
    this.config.period = p;
    if (this.task)
      this.task.interval = p;
  };

  this._Execute = function() {
    post('execute\n');
    this.config.execute && this.config.execute(this._Display());
  };

  // Length of the scrollable message (which is right-padded to fit the display.
  this._Length = function() {
    return Math.max(this._DisplayLength(), this.config.message.length);
  };

  // Length of the scroll display.
  this._DisplayLength = function() {
    return this.config.displayLength || Softstep.Scroller.defaultDisplayLength;
  };

  this._Period = function() {
    return Math.max(Softstep.Scroller.minimumPeriod,
                    this.config.period || Softstep.Scroller.defaultPeriod);
  };

  this._NewTask = function() {
    var t = new Task(this._Run, this);
    t.interval = this._Period();
    t.repeat(this.config.repeat * this._Length(), t.interval);
    return t;
  };

  // The string representing the display, always exactly _DisplayLength() long.
  this._Display = function() {
    var m = this.config.message || '';
    var len = this._DisplayLength();
    while (m.length < len) // Only good if len is not large.
      m += ' ';
    m += ' ';
    return (m + m).substring(this.offset, this.offset + len);
  };

  this._Increment = function() {
    this.offset += (this.config.delta || 1);
    var length = this._Length();

    if (this.offset < 0)
      this.offset = length - 1;

    else if (this.offset > length)
      this.offset = 0;
  };

  this._Run = function() {
    this._Increment();
    this._Execute();
  };
};

Softstep.Scroller.defaultDisplayLength = 4;
Softstep.Scroller.defaultPeriod = 200;
Softstep.Scroller.minimumPeriod = 20;

// I've taken Softstep.Scroller.minimumPeriod as low as 1 with no ill effects
// BUT the company warns you might brick your pedal.  BEWARE SETTING THIS TOO
// LOW.
var Max = new Object();
// Concatinate two arguments or argument lists, only returning a new list if
// both lists are non-empty.
//
// I wrote this some time ago.  My current thinking on this code is that it's a
// tiny bit faster, but less clear and less safe than simply creating a new list
// with Array.ConcatSafe and I'll probably get rid of this as a result.  (It's
// unsafe because if you modify the resturned result, you might be modifying one
// of the original arrays...!)
//
Array.Concat = function(x, y) {
  if (!(x && x.length))
    return y;
  if (!(y && y.length))
    return x;
  return Array.ConcatSafe(x, y);
};
Array.ConcatSafe = function(x, y) {
  // If x doesn't have the .concat method, it's an argument list: see
  // http://ax.to/jsarguments
  if (!x.concat)
    x = arrayfromargs(x);
  if (!y.concat)
    y = arrayfromargs(y);
  return x.concat(y);
};
// A "Functional" as either a function or an associative array (which is any
// Javascript object).
var Functional = {};
// Partial(f) partially binds arguments to the front or back of f, so that,
// for example:
//
//   Partial(f)      (a, b, c)(d, e, f) := f(a, b, c, d, e, f).
//   Partial(f, true)(a, b, c)(d, e, f) := f(d, e, f, a, b, c).
Functional.Partial = function(f, reversed) {
  return function(_) {
    var args = arguments;
    return function(_) {
      var arg1 = reversed ? arguments : args;
      var arg2 = reversed ? args : arguments;
      return f.apply(this, Array.Concat(arg1, arg2));
    };
  };
};
// You can override this in tests.
Max.Outlet = function(outletNumber, data) {
  outlet(outletNumber || 0, data);
};
// Returns a function that sends data to outlet "outletNumber".
Max.OutletFunction = function(outletNumber) {
  return function(data) {
    Max.Outlet(outletNumber, data);
  };
};
var _scroller = new Softstep.Scroller(
  {execute: Max.OutletFunction(0),
   message: "*** Tom Swirly's Scroller"}
);
function start() { _scroller.Start(); };
function stop() { _scroller.Stop(); };
function message(x) { _scroller.SetMessage('' + x); };
function period(x) { _scroller.SetPeriod(x); };
function forward(d) { _scroller_.config.delta = 1; };
function reverse(d) { _scroller_.config.delta = -1; };
post('scroller v0.4 compiled.\n');
